/**
 * Database Manager for Dan-AI-Mate Intelligence Dashboard
 * Integrates Firebase Firestore and GitHub for real-time data storage
 */

require('dotenv').config();
const admin = require('firebase-admin');
const { Octokit } = require('@octokit/rest');

class DatabaseManager {
  constructor() {
    this.initializeFirebase();
    this.initializeGitHub();
    this.activityLog = [];
    this.systemMetrics = {};
    this.goals = [];
    this.rules = [];
  }

  /**
   * Initialize Firebase Admin SDK
   */
  initializeFirebase() {
    try {
      // Initialize Firebase Admin SDK
      if (!admin.apps.length) {
        admin.initializeApp({
          credential: admin.credential.cert({
            projectId: process.env.FIREBASE_PROJECT_ID || 'dan-ai-mate-intelligence',
            clientEmail: process.env.FIREBASE_CLIENT_EMAIL,
            privateKey: process.env.FIREBASE_PRIVATE_KEY?.replace(/\\n/g, '\n')
          }),
          databaseURL: `https://${process.env.FIREBASE_PROJECT_ID || 'dan-ai-mate-intelligence'}.firebaseio.com`
        });
      }
      
      this.db = admin.firestore();
      console.log('✅ Firebase Firestore initialized');
    } catch (error) {
      console.warn('⚠️  Firebase not configured, using local storage:', error.message);
      this.db = null;
    }
  }

  /**
   * Initialize GitHub API
   */
  initializeGitHub() {
    try {
      this.octokit = new Octokit({
        auth: process.env.GITHUB_TOKEN
      });
      this.githubRepo = process.env.GITHUB_REPO || 'danielyoung/RepoClone';
      console.log('✅ GitHub API initialized');
    } catch (error) {
      console.warn('⚠️  GitHub not configured:', error.message);
      this.octokit = null;
    }
  }

  /**
   * Store activity log entry
   */
  async logActivity(activity) {
    const logEntry = {
      id: Date.now().toString(),
      timestamp: new Date().toISOString(),
      type: activity.type,
      message: activity.message,
      status: activity.status || 'completed',
      metadata: activity.metadata || {},
      system: activity.system || 'intelligence'
    };

    // Add to local cache
    this.activityLog.unshift(logEntry);
    if (this.activityLog.length > 100) {
      this.activityLog = this.activityLog.slice(0, 100);
    }

    // Store in Firestore
    if (this.db) {
      try {
        await this.db.collection('activity_log').doc(logEntry.id).set(logEntry);
      } catch (error) {
        console.warn('⚠️  Failed to store activity in Firestore:', error.message);
      }
    }

    // Store in GitHub as issue or commit
    if (this.octokit && activity.priority === 'high') {
      await this.createGitHubIssue(activity);
    }

    return logEntry;
  }

  /**
   * Create GitHub issue for high-priority activities
   */
  async createGitHubIssue(activity) {
    try {
      const [owner, repo] = this.githubRepo.split('/');
      
      await this.octokit.issues.create({
        owner,
        repo,
        title: `[Intelligence] ${activity.type}: ${activity.message}`,
        body: `
## Activity Log Entry

**Type:** ${activity.type}
**Message:** ${activity.message}
**Status:** ${activity.status}
**Timestamp:** ${new Date().toISOString()}

### Metadata
\`\`\`json
${JSON.stringify(activity.metadata, null, 2)}
\`\`\`

---
*Generated by Dan-AI-Mate Intelligence System*
        `,
        labels: ['intelligence', 'automated', activity.type.toLowerCase()]
      });
    } catch (error) {
      console.warn('⚠️  Failed to create GitHub issue:', error.message);
    }
  }

  /**
   * Update system metrics
   */
  async updateSystemMetrics(metrics) {
    const metricEntry = {
      id: Date.now().toString(),
      timestamp: new Date().toISOString(),
      ...metrics
    };

    // Update local cache
    this.systemMetrics = { ...this.systemMetrics, ...metrics };

    // Store in Firestore
    if (this.db) {
      try {
        await this.db.collection('system_metrics').doc('current').set(metricEntry);
      } catch (error) {
        console.warn('⚠️  Failed to store metrics in Firestore:', error.message);
      }
    }

    return metricEntry;
  }

  /**
   * Get recent activity log
   */
  async getActivityLog(limit = 50) {
    if (this.db) {
      try {
        const snapshot = await this.db
          .collection('activity_log')
          .orderBy('timestamp', 'desc')
          .limit(limit)
          .get();
        
        return snapshot.docs.map(doc => doc.data());
      } catch (error) {
        console.warn('⚠️  Failed to fetch activity from Firestore:', error.message);
      }
    }

    // Return local cache if Firestore is not available
    return this.activityLog.slice(0, limit);
  }

  /**
   * Get system metrics
   */
  async getSystemMetrics() {
    if (this.db) {
      try {
        const doc = await this.db.collection('system_metrics').doc('current').get();
        if (doc.exists) {
          return doc.data();
        }
      } catch (error) {
        console.warn('⚠️  Failed to fetch metrics from Firestore:', error.message);
      }
    }

    // Return local cache if Firestore is not available
    return this.systemMetrics;
  }

  /**
   * Store goals and rules
   */
  async storeGoalsAndRules(goals, rules) {
    const data = {
      timestamp: new Date().toISOString(),
      goals,
      rules
    };

    // Update local cache
    this.goals = goals;
    this.rules = rules;

    // Store in Firestore
    if (this.db) {
      try {
        await this.db.collection('intelligence_config').doc('goals_rules').set(data);
      } catch (error) {
        console.warn('⚠️  Failed to store goals/rules in Firestore:', error.message);
      }
    }

    return data;
  }

  /**
   * Get goals and rules
   */
  async getGoalsAndRules() {
    if (this.db) {
      try {
        const doc = await this.db.collection('intelligence_config').doc('goals_rules').get();
        if (doc.exists) {
          const data = doc.data();
          this.goals = data.goals;
          this.rules = data.rules;
          return data;
        }
      } catch (error) {
        console.warn('⚠️  Failed to fetch goals/rules from Firestore:', error.message);
      }
    }

    // Return local cache if Firestore is not available
    return {
      goals: this.goals,
      rules: this.rules
    };
  }

  /**
   * Get GitHub repository information
   */
  async getGitHubInfo() {
    if (!this.octokit) {
      return null;
    }

    try {
      const [owner, repo] = this.githubRepo.split('/');
      
      const [repoData, commits, issues] = await Promise.all([
        this.octokit.repos.get({ owner, repo }),
        this.octokit.repos.listCommits({ owner, repo, per_page: 5 }),
        this.octokit.issues.listForRepo({ owner, repo, state: 'open', per_page: 5 })
      ]);

      return {
        repository: {
          name: repoData.data.name,
          fullName: repoData.data.full_name,
          url: repoData.data.html_url,
          description: repoData.data.description,
          stars: repoData.data.stargazers_count,
          forks: repoData.data.forks_count,
          language: repoData.data.language
        },
        recentCommits: commits.data.map(commit => ({
          sha: commit.sha.substring(0, 7),
          message: commit.commit.message,
          author: commit.commit.author.name,
          date: commit.commit.author.date
        })),
        openIssues: issues.data.map(issue => ({
          number: issue.number,
          title: issue.title,
          state: issue.state,
          labels: issue.labels.map(label => label.name)
        }))
      };
    } catch (error) {
      console.warn('⚠️  Failed to fetch GitHub info:', error.message);
      return null;
    }
  }

  /**
   * Get dashboard data
   */
  async getDashboardData() {
    const [activityLog, systemMetrics, goalsRules, githubInfo] = await Promise.all([
      this.getActivityLog(20),
      this.getSystemMetrics(),
      this.getGoalsAndRules(),
      this.getGitHubInfo()
    ]);

    return {
      activityLog,
      systemMetrics,
      goals: goalsRules.goals || [],
      rules: goalsRules.rules || [],
      githubInfo,
      lastUpdated: new Date().toISOString()
    };
  }

  /**
   * Initialize default data
   */
  async initializeDefaultData() {
    const defaultGoals = [
      {
        name: 'Template Deployment System',
        description: 'A comprehensive system for deploying project templates with automated setup and configuration.',
        features: ['Automated template generation', 'Firebase hosting integration', 'Brand guideline enforcement'],
        status: 'In Development',
        priority: 'High',
        timeline: '2-3 weeks',
        confidence: 96
      },
      {
        name: 'Backend Logic Separation',
        description: 'Proper separation of backend logic from frontend components for maintainable architecture.',
        features: ['API layer separation', 'Service-oriented architecture', 'Clean code principles'],
        status: 'Planning',
        priority: 'Critical',
        timeline: '1-2 weeks',
        confidence: 92
      },
      {
        name: 'Brand Guidelines Enforcement',
        description: 'Automated enforcement of Dan-AI-Mate brand guidelines across all components.',
        features: ['Color scheme validation', 'Typography enforcement', 'Component consistency'],
        status: 'Active',
        priority: 'High',
        timeline: 'Ongoing',
        confidence: 89
      },
      {
        name: 'Firebase Hosting Integration',
        description: 'Seamless integration with Firebase hosting for template deployment.',
        features: ['Automated deployment', 'CDN optimization', 'SSL certificate management'],
        status: 'In Progress',
        priority: 'Medium',
        timeline: '1 week',
        confidence: 87
      },
      {
        name: 'Modern UI/UX Design',
        description: 'iPhone-style modern UI/UX design following latest design principles.',
        features: ['Glassmorphism effects', 'Smooth animations', 'Responsive design'],
        status: 'Active',
        priority: 'High',
        timeline: 'Ongoing',
        confidence: 94
      }
    ];

    const defaultRules = [
      {
        name: 'Backend Logic Separation',
        description: 'Enforces separation of backend logic from frontend components.',
        requirements: ['No backend code in root directory', 'Proper folder structure', 'API layer isolation'],
        enforcement: 'Automated',
        violations: 'High',
        impact: 'Critical',
        successRate: 98
      },
      {
        name: 'Dan-AI-Mate Brand Guidelines',
        description: 'Enforces consistent brand guidelines across all components.',
        requirements: ['Color scheme compliance', 'Typography standards', 'Component consistency'],
        enforcement: 'Automated',
        violations: 'Medium',
        impact: 'High',
        successRate: 96
      },
      {
        name: 'Project Template Standards',
        description: 'Ensures all project templates meet quality standards.',
        requirements: ['Proper structure', 'Documentation', 'Testing setup'],
        enforcement: 'Automated',
        violations: 'Low',
        impact: 'Medium',
        successRate: 94
      },
      {
        name: 'Firebase Hosting Integration',
        description: 'Enforces proper Firebase hosting configuration.',
        requirements: ['SSL certificates', 'CDN setup', 'Deployment automation'],
        enforcement: 'Automated',
        violations: 'Medium',
        impact: 'High',
        successRate: 92
      },
      {
        name: 'Modern iPhone-Style Design',
        description: 'Enforces modern UI/UX design principles.',
        requirements: ['Glassmorphism effects', 'Smooth animations', 'Responsive design'],
        enforcement: 'Automated',
        violations: 'Low',
        impact: 'Medium',
        successRate: 95
      }
    ];

    await this.storeGoalsAndRules(defaultGoals, defaultRules);

    // Log initial activity
    await this.logActivity({
      type: 'system_initialization',
      message: 'Dan-AI-Mate Intelligence Dashboard initialized with database integration',
      status: 'completed',
      priority: 'high'
    });

    console.log('✅ Default data initialized');
  }
}

module.exports = DatabaseManager; 